Curso de Servidores Web 
    • Introducción y conceptos 
    • Hosting 
Dentro de la elección de hosting tenemos muchas alternativas dependiendo de qué tipo de servicios necesitamos, con cuánto presupuesto contemos y otros servicios.
Una clasificación a grosso modo podría ser la siguiente:
    • Tradicional 
    • VPS ( Servidor Privado Virtual) 
    • Plesk / Cpanel ( Nada recomendables, muy poco flexibles ) 
    • PAAS / IAAS 
        ◦ Azure (Microsoft) 
        ◦ AWS (Amazon) 
        ◦ DigitalOcean 
        ◦ OpenStack 
    • PAAS 
        ◦ Heroku / Modulus 
    • Homing 

Curso de Servidores Web 
    • Introducción y conceptos 
    • Virtualización / Contenedores 
La virtualización nos va a permitir tener varios sistemas operativos ejecutándose a la vez en una misma máquina física. Esto es posible gracias a las CPU’s modernas que soportan extensiones VT (Intel) o AMD-V.
Hay distintos tipos de virtualización:
    • ParaVirtualización : No hacen uso de las extensiones de virtualización de la CPU, con lo cual el rendimiento es notablemente inferior.
    • Virtualización completa : Hacen uso de las extensiones de virtualización de la CPU. Es el caso más común 
Dentro de los tipos de virtualización, también podemos encontrarnos las que comparten un kernel común (LXC containers) y las que el host (Máquina física) y el guest tienen kernels diferentes.
Por lo general, las máquinas virtuales que comparten kernels tienen un mejor rendimiento y aprovechamiento de recursos.
La capa que gestiona la virtualización se conoce como Hypervisor.
Máquinas completas
Por máquinas completas nos referimos a aquéllas que no comparten kernel con el host.
    • Virtualbox
    • VMware
    • KVM 
Contenedores
    • XEN
    • Docker 

Curso de Servidores Web 
    • Tipos de Servidores Web 
    • Introducción 
Hay muchas alternativas a la hora de servir contenido vía web, y no siempre pasan por las soluciones tradicionales de Apache o Nginx.
Dependiendo de la naturaleza del proyecto, a veces puedes optar por soluciones más sencillas.
Pongamos un ejemplo concreto: Imaginemos que tenemos un proyecto en el que vamos a crear una web para una documentación técnica de un proyecto.Ahora, hazte las siguientes preguntas:
    • ¿Realmente necesito una base de datos ?
    • ¿Con qué frecuencia se va actualizar el contenido ?
    • ¿Tengo que generar contenido al vuelo? 
Desde hace un tiempo, mucha gente se hizo esta pregunta, y a día de hoy podéis encontrar muchos sitios web totalmente estáticos, sin necesidad de bases de datos o un lenguaje en backend que tenga que procesar los documentos o peticiones.
Este ejemplo tiene la finalidad de demostrar que cada proyecto es diferente y que a veces el caso de uso, puede facilitarnos incluso la tarea de llevarlo a cabo.
Como tarea, piensa en las posibles ventajas que tendría un proyecto de este tipo en cuestión de seguridad y mantenimiento.
CONSEJO : En el mundo técnico os encontraréis con muchas comparaciones, benchmarks y flame-wars entre una solución y otra. No se trata de saber cúal es el mejor servidor, si no de qué servidor se adapta mejor a nuestro caso de uso específico. En los casos en los que podáis decidir qué servidor usar, centraros en cúal se ajusta mejor a vuestro problema.
Curso de Servidores Web 
    • Tipos de Servidores Web 
    • Servidores Web más populares 
Como ya es conocido por todos, cuando hablamos de servidor web nos viene a la cabeza un par de nombres: Apache y Nginx , pero al mismo tiempo se nos puede hacer difícil el compararlos.
Si quieres consultar una lista práctica de consideraciones sobre ellos, puedes consultar este documento:
    •  Apache vs Nginx: Practical Considerations
Curso de Servidores Web 
    • Tipos de Servidores Web 
    • Stacks 
Se llama Stack a un conjunto de tecnologías que se escogen como herramientas para implementar la solución de un proyecto. Generalmente se usan para dar una descripción de la arquitectura de un modo rápido.
Veamos algunos ejemplos:
    • LAMP ( Linux - Apache - MySQL - PHP)
    • LEMP ( Linux - Engine X - MySQL - PHP)
    • MEAN ( Mongo - ExpressJS - Angular - NodeJS) 
Curso de Servidores Web 
    • Tipos de Servidores Web 
    • Servidores de Aplicaciones 
Este tipo de servidores los vas a encontrar en grandes corporaciones, donde el lenguaje de programación está muy ligado a toda la infraestructura y despliegue de las aplicaciones.
Generalmente encontrarás soluciones basadas en Java o .NET
Algunos de los más conocidos:
    • JBoss
    • Tomcat
    • Weblogic 
Si tienes interés por ver un listado más amplio de los distinto servidores de aplicaciones, puedes consultar esta comparación de servidores de aplicaciones.

Curso de Servidores Web 
    • Tipos de Servidores Web 
    • Web Frameworks 
Los web frameworks son un conjunto de abstracciones sobre operaciones comunes en la construcción de una aplicación web. Muchos frameworks se escriben en un determinado lenguaje de programación, ya que esto permite aprovechar el paradigma del lenguaje en sí. Por eso es importante también la elección del lenguaje de programación a la hora de decidir un framework ya que este nos permitirá afrontar de manera más cómoda y más natural una serie de problemas para los que el paradigma de programación está pensado.
Evidentemente, es complicado el tener gente en el equipo que domine o se sienta cómodo en varios lenguajes de programación con paradigmas distintos, con lo que muchas veces el cambio de un lenguaje no será posible, y tendréis que acomodaros a las posibilidades del equipo.
Los webframeworks pretenden establecer un patrón de funcionamiento para resolver ciertas tareas que una aplicación web nos va requerir. Estas son algunas de ellas:
    • Enrutado
    • Templating
    • MVC
    • Scaffolding 
Los webframeworks pueden ser generalistas, o bien específicos para resolver una determinada área como un CMS, una tienda, un portal , etc…
A continuación os muestro una lista con Web Frameworks con su lenguaje de programación asociado:
    • Symphony ( PHP )
    • RoR ( Ruby on Rails )
    • Django ( Python )
    • Spring (Java)
    • Express ( NodeJS )
    • Meteor ( NodeJS )
    • Phoenix ( Elixir ) 

Curso de Servidores Web 
    • Tipos de Servidores Web 
    • Bases de datos 
Muchas de las aplicaciones necesitan implementar un sistema de persistencia de datos. Según la duración de tiempo que necesitemos el dato, se pueden establecer distintos mecanismos.
Las bases de datos tienen una relación directa con el Modelo de Datos de nuestra aplicación. Un error muy frecuente en las aplicaciones web, es no dedicarle el suficiente tiempo a escoger una base de datos acorde con el modelo de datos que se ajuste mejor al problema que tenemos que resolver.
Evidentemente, la elección de una base de datos conlleva una serie de ventajas e inconvenientes. Por ejemplo:
    • Una base de datos relacional: 
        ◦ cumplirá el principio ACID (Atomicity, Consistency, Isolation, Durability)
        ◦ pensada para escalar verticalmente por lo general, ( Aunque puede haber estrategias de escalado horizontal)
        ◦ el modo de almacenamiento no corresponde exactamente con la estructura del dato que se almacena ( no ORM)
        ◦ JOIN es una operación común
    • Una base de datos NOSQL: 
        ◦ No se puede hacer JOINs directamente en la base de datos
        ◦ Tiene consistencia eventual
        ◦ La estructura de datos almacenada coincide con la estructura de datos (ORM)
        ◦ pensada para escalar horizontalmente
        ◦ No es sólo de un tipo ( Mucha genete asocia NOSQL a MongoDB, que es una base de datos orientada a documentos, uno de los disitintos tipos que hay)
Dentro de los dos grandes tipos de bases de datos,te mostramos algunos ejemplos:
    • Relacionales: Mysql/MariaDB , PostgresSQL, Oracle, SQL Server…
    • NOSQL (No Sólo Relacionales : MongoDB, Redis, CouchDB, Neo4J ) 
Para consultar una clasificación más extensa , consulta esta clasificación de bases de datos NOSQL

Curso de Servidores Web 
    • Apache y NGINX (Configuraciones comunes Side By Side) 
    • Introducción a Vagrant 
En esta sesión vamos a utilizar Vagrant para prototipar cada una de las máquinas virtuales con las que vamos a trabajar.
Vagrant es una herramienta que nos va a permitir automatizar la creación e instalación de nuevas máquinas virtuales mediante un fichero de configuración VagrantFile y una serie de scripts de provisión que nos permitirán:
    • Instalar o desinstalar paquetes 
    • Modificar configuraciones 
Hay muchas alternativas para la provisión de las máquinas: desde scripts de shell hasta sistemas de configuración centralizada como cfengine, chef, puppet, ansible , etc… . Si quieres consultar todas las opciones posibles, consulta la documentación sobre provisionamiento.
Para instalar Vagrant en nuestra máquina, simplemente accede a la sección de descargas de la página oficial e instala la versión correspondiente a tu sistema operativo.
Una vez instalado , desde un terminal teclea:
vagrant list-commands
Con el comando anterior verás todas los comandos posibles.
AVISO Recomendamos realizar este proceso desde una máquina con Linux o Mac, ya que vamos a emplear muchos comandos de terminal, y realizarlo en Windows es un tanto tedioso.
Instalando una Box
Configuración de Parámetros
Todas las máquinas virtuales generadas con Vagrant tienen un fichero de configuración llamado VagrantFile. En este fichero se configuran:
    • la mayoría los parámetros de la VM ( los mismos parámetros que configurarías en el GUI de VirtualBox o con VBoxManage) 
    • los scripts de provisión. 
    • Estrategias de despliegue 
COMENTARIO : Generalmente encontrarás comentarios explicativos de cada configuración en el VagrantFile.
Veamos un fichero de ejemplo:
# -*- mode: ruby -*-
# vi: set ft=ruby :

# All Vagrant configuration is done below. The "2" in Vagrant.configure
# configures the configuration version (we support older styles for
# backwards compatibility). Please don't change it unless you know what
# you're doing.
Vagrant.configure(2) do |config|
  # The most common configuration options are documented and commented below.
  # For a complete reference, please see the online documentation at
  # https://docs.vagrantup.com.

  # Every Vagrant development environment requires a box. You can search for
  # boxes at https://atlas.hashicorp.com/search.
  config.vm.box = "ubuntu/trusty64"

  # Disable automatic box update checking. If you disable this, then
  # boxes will only be checked for updates when the user runs
  # `vagrant box outdated`. This is not recommended.
  # config.vm.box_check_update = false

  # Create a forwarded port mapping which allows access to a specific port
  # within the machine from a port on the host machine. In the example below,
  # accessing "localhost:8080" will access port 80 on the guest machine.
  # config.vm.network "forwarded_port", guest: 80, host: 8080

  # Create a private network, which allows host-only access to the machine
  # using a specific IP.
  # config.vm.network "private_network", ip: "192.168.33.10"

  # Create a public network, which generally matched to bridged network.
  # Bridged networks make the machine appear as another physical device on
  # your network.
  # config.vm.network "public_network"

  # Share an additional folder to the guest VM. The first argument is
  # the path on the host to the actual folder. The second argument is
  # the path on the guest to mount the folder. And the optional third
  # argument is a set of non-required options.
  # config.vm.synced_folder "../data", "/vagrant_data"

  # Provider-specific configuration so you can fine-tune various
  # backing providers for Vagrant. These expose provider-specific options.
  # Example for VirtualBox:
  #
  # config.vm.provider "virtualbox" do |vb|
  #   # Display the VirtualBox GUI when booting the machine
  #   vb.gui = true
  #
  #   # Customize the amount of memory on the VM:
  #   vb.memory = "1024"
  # end
  #
  # View the documentation for the provider you are using for more
  # information on available options.

  # Define a Vagrant Push strategy for pushing to Atlas. Other push strategies
  # such as FTP and Heroku are also available. See the documentation at
  # https://docs.vagrantup.com/v2/push/atlas.html for more information.
  # config.push.define "atlas" do |push|
  #   push.app = "YOUR_ATLAS_USERNAME/YOUR_APPLICATION_NAME"
  # end

  # Enable provisioning with a shell script. Additional provisioners such as
  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the
  # documentation for more information about their specific syntax and use.
  # config.vm.provision "shell", inline: <<-SHELL
  #   sudo apt-get update
  #   sudo apt-get install -y apache2
  # SHELL
end
Scripts de provisión
En este caso, vamos a emplear el método de scripts de shell. Veamos un ejemplo de cómo espeficar en el Vagrantfile una provisión vía shell
Vagrant.configure("2") do |config|
  config.vm.provision "shell", path: "script.sh"
end


Curso de Servidores Web 
    • Apache y NGINX (Configuraciones comunes Side By Side) 
    • Configuraciones comunes 
A continuación veremos unas cuantas configuraciones habituales tanto en Apache como en Nginx. Muchas de estas configuraciones se pueden obtener desde un generador de configuraciones de yeoman .
Ficheros de configuración
Apache
/etc/apache2/
Nginx
/etc/nginx
ATENCIÓN : Dependiendo de la distribución de linux que utilices, puedes encontrar que el nombre de apache2 o el de nginx difiere. Los directorios mostrados son los que hay por defecto en una instalación en Ubuntu.
Parámetros de conexión
Workers
ATENCIÓN Si en el Vagrantfile no especificamos el número de cores (Siempre y cuando estemos en un equipo que tenga más de un core), evidentemente el número de cores será uno, y en el caso de nginx, veremos sólo un worker. Para especificar más de un core en el Vagrantfile , sigue este ejemplo:
config.vm.provider "virtualbox" do |v|
  v.memory = 1024
  v.cpus = 2
end
Apache
En el caso de Apache, tres modos de funcionamiento (MPM):
    • mpm_prefork 
    • mpm_worker 
    • mpm_events 
Para saber qué modo está activado por defecto, tendremos que consultar el contenido de la carpeta mods-enabled.
ls -l /etc/apache2/mods-enabled/ | grep mpm
Para activar un modo distinto al habilitado procederemos de la siguiente forma:
a2dismod mpm_event
a2enmod mpm_prefork
service apache2 restart
Se puede modificar el número de workers en el fichero de configuración respectivo de cada módulo.
Nginx
Para aprovechar todos los cores de la máquina en la que estemos, es recomendable dejar la opción por defecto. El resultado será que se levanten tantos workers como cores tenga la cpu.
worker_processes auto;
Puertos
Apache
En este caso, con la configuración por defecto deberíamos editar el fichero ports.conf si queremos hacer una configuración general.
Listen 80

<IfModule ssl_module>
  Listen 443
</IfModule>

<IfModule mod_gnutls.c>
  Listen 443
</IfModule>
En el caso en el que tengamos una configuración con VirtualHosts , cada uno puede llevar su propia configuración de puertos.
Nginx
Dentro de un bloque server
listen 80 default_server;
listen [::]:80 default_server ipv6only=on;
Timeouts
Apache
En Apache además de los parámetros genéricos Timeout y KeepAliveTimeout , podemos hacer uso de los parámetros incluídos en el módulo mod_reqtimeout:
Nginx
Dependiendo del rol que tenga nginx en tu arquitectura ( como Proxy , como servidor de estáticos, etc…) habrá que tener en cuenta en qué bloque y qué valor de configuración tomamos.
Vamos a tomar como referencia este post, pero tened en cuenta que estos no son los únicos parámetros.
    • keepalive_timeout 10; (75) 
    • keepalive_requests 1024; (100) 
    • client_header_timeout 10; (60) 
    • client_body_timeout 10; (60) 
    • send_timeout 10; (60) 
    • sendfile on; (off) 
    • tcp_nopush on; (off) 
    • tcp_nodelay on; (on) 
Caché (ETAGS y otras alternativas)
Apache
# ----------------------------------------------------------------------
# | ETags                                                              |
# ----------------------------------------------------------------------

# Remove `ETags` as resources are sent with far-future expires headers.
#
# https://developer.yahoo.com/performance/rules.html#etags
# https://tools.ietf.org/html/rfc7232#section-2.3

# `FileETag None` doesn't work in all cases.
<IfModule mod_headers.c>
    Header unset ETag
</IfModule>

FileETag None

# ----------------------------------------------------------------------
# | Expires headers                                                    |
# ----------------------------------------------------------------------

# Serve resources with far-future expires headers.
#
# (!) If you don't control versioning with filename-based
# cache busting, you should consider lowering the cache times
# to something like one week.
#
# https://httpd.apache.org/docs/current/mod/mod_expires.html

<IfModule mod_expires.c>

    ExpiresActive on
    ExpiresDefault                                      "access plus 1 month"

  # CSS

    ExpiresByType text/css                              "access plus 1 year"


  # Data interchange

    ExpiresByType application/atom+xml                  "access plus 1 hour"
    ExpiresByType application/rdf+xml                   "access plus 1 hour"
    ExpiresByType application/rss+xml                   "access plus 1 hour"

    ExpiresByType application/json                      "access plus 0 seconds"
    ExpiresByType application/ld+json                   "access plus 0 seconds"
    ExpiresByType application/schema+json               "access plus 0 seconds"
    ExpiresByType application/vnd.geo+json              "access plus 0 seconds"
    ExpiresByType application/xml                       "access plus 0 seconds"
    ExpiresByType text/xml                              "access plus 0 seconds"


  # Favicon (cannot be renamed!) and cursor images

    ExpiresByType image/vnd.microsoft.icon              "access plus 1 week"
    ExpiresByType image/x-icon                          "access plus 1 week"

  # HTML

    ExpiresByType text/html                             "access plus 0 seconds"


  # JavaScript

    ExpiresByType application/javascript                "access plus 1 year"
    ExpiresByType application/x-javascript              "access plus 1 year"
    ExpiresByType text/javascript                       "access plus 1 year"


  # Manifest files

    ExpiresByType application/manifest+json             "access plus 1 week"
    ExpiresByType application/x-web-app-manifest+json   "access plus 0 seconds"
    ExpiresByType text/cache-manifest                   "access plus 0 seconds"


  # Media files

    ExpiresByType audio/ogg                             "access plus 1 month"
    ExpiresByType image/bmp                             "access plus 1 month"
    ExpiresByType image/gif                             "access plus 1 month"
    ExpiresByType image/jpeg                            "access plus 1 month"
    ExpiresByType image/png                             "access plus 1 month"
    ExpiresByType image/svg+xml                         "access plus 1 month"
    ExpiresByType image/webp                            "access plus 1 month"
    ExpiresByType video/mp4                             "access plus 1 month"
    ExpiresByType video/ogg                             "access plus 1 month"
    ExpiresByType video/webm                            "access plus 1 month"


  # Web fonts

    # Embedded OpenType (EOT)
    ExpiresByType application/vnd.ms-fontobject         "access plus 1 month"
    ExpiresByType font/eot                              "access plus 1 month"

    # OpenType
    ExpiresByType font/opentype                         "access plus 1 month"

    # TrueType
    ExpiresByType application/x-font-ttf                "access plus 1 month"

    # Web Open Font Format (WOFF) 1.0
    ExpiresByType application/font-woff                 "access plus 1 month"
    ExpiresByType application/x-font-woff               "access plus 1 month"
    ExpiresByType font/woff                             "access plus 1 month"

    # Web Open Font Format (WOFF) 2.0
    ExpiresByType application/font-woff2                "access plus 1 month"


  # Other

    ExpiresByType text/x-cross-domain-policy            "access plus 1 week"

</IfModule>
Nginx
Para habilitar ETAGS ( los contextos pueden ser http, server y location) :
etag on;
Para establecer la expiración de documentos estáticos:
# Expire rules for static content

# No default expire rule. This config mirrors that of apache as outlined in the
# html5-boilerplate .htaccess file. However, nginx applies rules by location,
# the apache rules are defined by type. A consequence of this difference is that
# if you use no file extension in the url and serve html, with apache you get an
# expire time of 0s, with nginx you'd get an expire header of one month in the
# future (if the default expire rule is 1 month). Therefore, do not use a
# default expire rule with nginx unless your site is completely static

# cache.appcache, your document html and data
location ~* \.(?:manifest|appcache|html?|xml|json)$ {
  expires -1;
  access_log logs/static.log;
}

# Feed
location ~* \.(?:rss|atom)$ {
  expires 1h;
  add_header Cache-Control "public";
}

# Media: images, icons, video, audio, HTC
location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ {
  expires 1M;
  access_log off;
  add_header Cache-Control "public";
}

# CSS and Javascript
location ~* \.(?:css|js)$ {
  expires 1y;
  access_log off;
  add_header Cache-Control "public";
}

# WebFonts
# If you are NOT using cross-domain-fonts.conf, uncomment the following directive
# location ~* \.(?:ttf|ttc|otf|eot|woff|woff2)$ {
#  expires 1M;
#  access_log off;
#  add_header Cache-Control "public";
# }
Para cachear respuestas de sistema cuando se piden ficheros:
# This tells Nginx to cache open file handles, "not found" errors, metadata about files and their permissions, etc.
#
# The upside of this is that Nginx can immediately begin sending data when a popular file is requested,
# and will also know to immediately send a 404 if a file is missing on disk, and so on.
#
# However, it also means that the server won't react immediately to changes on disk, which may be undesirable.
#
# In the below configuration, inactive files are released from the cache after 20 seconds, whereas
# active (recently requested) files are re-validated every 30 seconds.
#
# Descriptors will not be cached unless they are used at least 2 times within 20 seconds (the inactive time).
#
# A maximum of the 1000 most recently used file descriptors can be cached at any time.
#
# Production servers with stable file collections will definitely want to enable the cache.
open_file_cache          max=1000 inactive=20s;
open_file_cache_valid    30s;
open_file_cache_min_uses 2;
open_file_cache_errors   on;
Hay otras opciones de cacheo, y dependiendo del rol que ocupe nginx en nuestra arquitectura , el cacheo se puede hacer a nivel de proxy. Para más información, consulta esta guía
Logs
Apache
# Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
# error, crit, alert, emerg.
# It is also possible to configure the loglevel for particular
# modules, e.g.
#LogLevel info ssl:warn

ErrorLog ${APACHE_LOG_DIR}/error.log
CustomLog ${APACHE_LOG_DIR}/access.log combined
Nginx
# Default error log file
# (this is only used when you don't override error_log on a server{} level)
error_log  logs/error.log warn;
# Format to use in log files
log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                  '$status $body_bytes_sent "$http_referer" '
                  '"$http_user_agent" "$http_x_forwarded_for"';

# Default log file
# (this is only used when you don't override access_log on a server{} level)
access_log logs/access.log main;
VirtualHosts
Apache
Generalmente , es buena practica el separar los VirtualHosts en ficheros. Con la instalación de Apache tienes un ejemplo en la carpeta sites-enabled
<VirtualHost *:80>
    # The ServerName directive sets the request scheme, hostname and port that
    # the server uses to identify itself. This is used when creating
    # redirection URLs. In the context of virtual hosts, the ServerName
    # specifies what hostname must appear in the request's Host: header to
    # match this virtual host. For the default virtual host (this file) this
    # value is not decisive as it is used as a last resort host regardless.
    # However, you must set it for any further virtual host explicitly.
    #ServerName www.example.com

    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/html

    # Available loglevels: trace8, ..., trace1, debug, info, notice, warn,
    # error, crit, alert, emerg.
    # It is also possible to configure the loglevel for particular
    # modules, e.g.
    #LogLevel info ssl:warn

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

    # For most configuration files from conf-available/, which are
    # enabled or disabled at a global level, it is possible to
    # include a line for only one particular virtual host. For example the
    # following line enables the CGI configuration for this host only
    # after it has been globally disabled with "a2disconf".
    #Include conf-available/serve-cgi-bin.conf
</VirtualHost>
Nginx
en el contexto de http, cada bloque server , implica un VirtualHost.
ACLARACIÓN : Al igual que hemos comentado antes, para mantener un cierto orden, puedes aprovechar la directiva include para establecer un directorio sites-enabled y establecer por ficheros las configuraciones de tus sites.
server {
    listen 127.0.0.1:8080;
    # The rest of server configuration
}
HSTS
Apache
<IfModule mod_headers.c>
    Header always set Strict-Transport-Security "max-age=16070400;"
</IfModule>
Nginx
# HSTS (HTTP Strict Transport Security)
# This header tells browsers to cache the certificate for a year and to connect exclusively via HTTPS.
add_header Strict-Transport-Security "max-age=31536000;";
CSP
Como aparece en el comentario más abajo, configurar una política de seguridad de contenidos puede llegar a ser confuso, y en algunos casos impracticable en función de los requisitos del proyecto (Dar soporte a navegadores antiguos que no soporten csp).
Para una referencia más a fondo, podéis consultar :
    • cspisawesome 
    • HTTP Headers - The simplest security 
Apache
En el fichero de configuración general apache2.conf:
<IfModule mod_headers.c>
     Header set Content-Security-Policy "script-src 'self'; object-src 'self'"

     # `mod_headers` cannot match based on the content-type, however,
     # the `Content-Security-Policy` response header should be send
     # only for HTML documents and not for the other resources.

     <FilesMatch "\.(appcache|atom|bbaw|bmp|crx|css|cur|eot|f4[abpv]|flv|geojson|gif|htc|ico|jpe?g|js|json(ld)?|m4[av]|manifest|map|mp4|oex|og[agv]|opus|otf|pdf|png|rdf|rss|safariextz|svgz?|swf|topojson|tt[cf]|txt|vcard|vcf|vtt|webapp|web[mp]|webmanifest|woff2?|xloc|xml|xpi)$">
         Header unset Content-Security-Policy
     </FilesMatch>
</IfModule>
Nginx
# with Content Security Policy (CSP) enabled (and a browser that supports it (http://caniuse.com/#feat=contentsecuritypolicy),
# you can tell the browser that it can only download content from the domains you explicitly allow
# CSP can be quite difficult to configure, and cause real issues if you get it wrong
# There is website that helps you generate a policy here http://cspisawesome.com/
add_header Content-Security-Policy "default-src 'self'; style-src 'self' 'unsafe-inline'; script-src 'self' https://www.google-analytics.com;";

CORS
Apache
# ######################################################################
# # CROSS-ORIGIN                                                       #
# ######################################################################

# ----------------------------------------------------------------------
# | Cross-origin requests                                              |
# ----------------------------------------------------------------------

# Allow cross-origin requests.
#
# https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS
# http://enable-cors.org/
# http://www.w3.org/TR/cors/

<IfModule mod_headers.c>
     Header set Access-Control-Allow-Origin "*"
</IfModule>

# ----------------------------------------------------------------------
# | Cross-origin images                                                |
# ----------------------------------------------------------------------

# Send the CORS header for images when browsers request it.
#
# https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image
# https://blog.chromium.org/2011/07/using-cross-domain-images-in-webgl-and.html

<IfModule mod_setenvif.c>
    <IfModule mod_headers.c>
        <FilesMatch "\.(bmp|cur|gif|ico|jpe?g|png|svgz?|webp)$">
            SetEnvIf Origin ":" IS_CORS
            Header set Access-Control-Allow-Origin "*" env=IS_CORS
        </FilesMatch>
    </IfModule>
</IfModule>

# ----------------------------------------------------------------------
# | Cross-origin web fonts                                             |
# ----------------------------------------------------------------------

# Allow cross-origin access to web fonts.

<IfModule mod_headers.c>
    <FilesMatch "\.(eot|otf|tt[cf]|woff2?)$">
        Header set Access-Control-Allow-Origin "*"
    </FilesMatch>
</IfModule>

# ----------------------------------------------------------------------
# | Cross-origin resource timing                                       |
# ----------------------------------------------------------------------

# Allow cross-origin access to the timing information for all resources.
#
# If a resource isn't served with a `Timing-Allow-Origin` header that
# would allow its timing information to be shared with the document,
# some of the attributes of the `PerformanceResourceTiming` object will
# be set to zero.
#
# http://www.w3.org/TR/resource-timing/
# http://www.stevesouders.com/blog/2014/08/21/resource-timing-practical-tips/

<IfModule mod_headers.c>
     Header set Timing-Allow-Origin: "*"
</IfModule>

Nginx
 add_header "Access-Control-Allow-Origin" "subdomain.example.com";


Curso de Servidores Web 
    • Montando Stacks (I) 
    • PHP 
PHP en el contexto de Apache
Como ya hemos comentado anteriormente en otra sesión, Apache presenta varios modos de funcionamiento en base a los MPM (Módulos de Múltiprocesamiento).
Para determinar que MPM utlizaríamos, debemos tener en cuenta varios factores:
    • Si el mismo servidor va a alojar varios sites en forma de VirtualHosts
    • Si la web va a requerir mucho procesamiento de CPU
    • Si lo que prima es atender un alto volumen de peticiones concurrentes con restricciones en cuanto a hardware 
En el caso en el que optemos por FastCGI tendríamos dos alternativas posibles:
    • PHP-FPM 
    • FCGI (mod_fcgid) 
Ejemplo con PHP-FPM
    • Lo primero que debemos hacer es instalar los paquetes necesarios ( Podemos incluirlos en el script de provision que tenemos con Vagrant ) 
NOTA : En esta ocasión vamos a instalar Apache y PHP desde otro repositorio distinto de los que vienen por defecto.
sudo add-apt-repository -y ppa:ondrej/apache2
sudo add-apt-repository -y ppa:ondrej/php5-5.6
sudo apt-get install -y apache2
sudo apt-get install -y php5-fpm \
     php5-mcrypt php5-mysql php5-gd php5-curl
    • Levantaremos la máquina ya con todos los paquetes necesarios 
vagrant up
    • Ya que vamos a usar FastCGI, vamos a configurar Apache para que haga de proxy ante peticiones php y se las mande al procesador de php directamente. Para ello tendremos que habilitar un par de modulos de apache: 
        ◦ mod_proxy 
        ◦ mod_proxy_fcgi 
sudo a2enmod proxy proxy_fcgi
sudo service apache2 restart
    • También nos tendremos que asegurar de que el modo MPM_event es el que está habilitado: 
ls -l /etc/apache2/mods-enabled | grep mpm
    • Creamos una carpeta donde vamos a alojar nuestro site. (Luego referenciaremos esta carpeta creada en la configuración del VirtualHost) 
sudo mkdir -p /var/www/ow-fastcgi.com/public
    • Ahora crearemos un VirtualHost (ow-fastcgi.conf) en la carpeta 
/etc/apache2/sites-available/
<VirtualHost *:80>
    ServerName ow-fastcgi.com
    ServerAlias www.ow-fastcgi.com


    DocumentRoot /var/www/ow-fastcgi.com/public

    <Directory /var/www/ow-fastcgi.com/public>
        Options -Indexes +FollowSymLinks +MultiViews
        AllowOverride All
        Require all granted
    </Directory>

    <FilesMatch \.php$>
        # 2.4.10+ can proxy to unix socket
        # SetHandler "proxy:unix:/var/run/php5-fpm.sock|fcgi://localhost/"

        # Else we can just use a tcp socket:
        SetHandler "proxy:fcgi://127.0.0.1:9000"
    </FilesMatch>

    ErrorLog ${APACHE_LOG_DIR}/example.com-error.log

    # Possible values include: debug, info, notice, warn, error, crit,
    # alert, emerg.
    LogLevel warn

    CustomLog ${APACHE_LOG_DIR}/ow-fastcgi.com-access.log combined

</VirtualHost>
    • Creamos un fichero prueba.php en la carpeta: 
/var/www/ow-fastcgi.com/public/
con el siguiente contenido:
<?php
  phpinfo();
?>
    • Habilitamos el VirtualHost (site) y deshabilitamos el que viene por defecto: 
sudo a2dissite 000-default
sudo a2ensite ow-fastcgi
sudo service apache2 restart
Si todo ha ido bien, accedemos con la ip de la máquina virtual mediante un navegador, y deberíamos ver la página con toda la información sobre la versión de php instalada.
PHP en el contexto de Nginx
La configuración más común suele ser el utilizar a Nginx como proxy hacia un procesador de PHP (FastCGI, uwsgi, SCGI…). Nginx detectará peticiones hacia ficheros php y le pasará el control al procesador php que tengamos configurado.
FastCGI es un protocolo distinto, y no es capaz de leer cabeceras HTTP, por lo que a nivel de proxy tendremos que hacer una conversión de cabeceras (Si las hubiera y fueran necesarias para el script PHP) a parámetros para FastCGI.
Es importante tener en cuenta que los distintos procesadores de PHP tienen formas distintas de procesar los argumentos que nginx le puede llegar a pasar, con lo que debemos conocer cómo trata nuestro procesador los argumentos que potencialmente Nginx le va a a pasar.
Para más información sobre FPM (FastCGI Process Manager), podeís consultar el manual de FPM en la documentación oficial de PHP
ACLARACIÓN : debido a la sobrecarga de acrónimos, muchas veces puede llevar a confusión. Lee este post en serverfault
FastCGI
A continuación os presentamos un resumen de los puntos más importantes a tener en cuenta cuando optamos por FastCGI
ATRIBUCIÓN : Mucha de esta información ha sido extraída de un post escrito por Justing Ellingwood. Recomendamos su lectura completa, ya que ofrece una visión detallada de todo el funcionamiento con FastCGI.
Directivas más comunes
    • fastcgi_pass: es la directiva encarga de indicar dónde se encuentra nuestro procesador FastCGI. Tenemos dos posibles opciones de comunicación entre Nginx y FastCGI :
        ◦ Via Network Socket: 
location ~ \.php$ {
  ...
  fastcgi_pass 127.0.0.1:9000;
  ...
}
- Via Unix Socket:
location ~ \.php$ {
  ...
  fastcgi_pass unix:/var/run/php5-fpm.sock;
  ...
}
    • fastcgi_param: la directiva(Array) en la que se setean los valores para los distintos parámetros que se le pasarán a FastCGI. 
location ~ \.php$ {
  ...
  fastcgi_param QUERY_STRING $query_string;
  fastcgi_param CONTENT_TYPE $content_type;
  fastcgi_param CONTENT_LENGTH $content_length;
  ...
}
    • try_files : No es una directiva específica de FastCGI pero se emplea también como paso previo de “sanitización de parámetros” para asegurarnos de que el recurso exite. 
location ~ \.php$ {
  ...
  try_files $uri =404;
  ...
}
    • include : otra directiva que no es específica de FastCGI, pero que nos permite tener agrupadas configuraciones para varios servicios evitando duplicidades.
    • fastcgi_split_path_info : directiva que mediante una expressión regular nos permite capturar dos grupos en dos variables:
        ◦ $fastcgi_script_name : El nombre del script 
        ◦ $fastcgi_path_info : el path capturado en la petición. 
location ~ [^/]\.php(/|$) {

    fastcgi_split_path_info ^(.+?\.php)(.*)$;
    set $orig_path $fastcgi_path_info;

    try_files $fastcgi_script_name =404;

    fastcgi_pass unix:/var/run/php5-fpm.sock;
    fastcgi_index index.php;
    include fastcgi_params;

    fastcgi_param SCRIPT_FILENAME $request_filename;
    fastcgi_param PATH_INFO $orig_path;
    fastcgi_param PATH_TRANSLATED $document_root$orig_path;
}
    • fastcgi_index : directiva útil cuando el parámetro SCRIPT_FILENAME tiene como valor $document_root$fastcgi_script_name y bloque location está configurado para aceptar peticiones con valores a continuación del nombre del script (QUERY_STRING).
    • fastcgi_intercept_errors : esta directiva nos permite decidir qué hacer con los errores generados por el procesador de PHP. Si el procesador genera un HTTP status code 300 o mayor, podemos pasárselos bien a Nginx para que lo trate con la directiva error_page o bien directamente al cliente.
Variables comúnmente usadas con FastCGI
ACLARACIÓN : Algunas de estas variables se encuentran definidas en el core de Nginx y otras en módulo de FastCGI.
    • $query_string o $args : los parámetros de la petición original.
    • $is_args : será igual a “?” si la petición recibida contiene parámetros.En otro caso devolverá una cadena vacía. Es útil en casos en los que tenemos que comprobar si hay parámetros o no.
    • $request_method : indica el método(verbo) HTTP con el que se ha recibido la petición.
    • $content_type : el valor que contenga la cabecera HTTP Content-Type de la petición. Si una petición POST llega con un body, la información de la cabecera indica cómo tratar ese body, de acuerdo a los mime-types.
    • $content_length : el valor de la cabecera HTTP Content-Length establecida o enviada por el cliente. Recuerda que para las peticiones con POST, este valor debe de estar indicado.
    • $fastcgi_script_name : toma valor siempre y cuando empleemos la directiva fastcgi_split_path_info.
    • $fastcgi_path_info : toma valor siempre y cuando empleemos la directiva fastcgi_split_path_info.
    • $request_filename : contiene el valor del path completo de la petición.
    • $request_uri : su valor es de la petición original completa, incluyendo la QUERY_STRING si la hubiera.
    • $document_root : contiene el valor del document_root, que generalmente se setea con las directivas root y alias.
    • $uri : contiene el valor final de la uri una vez procesada ( ya sea por por directivas rewrite u otro procesamiento previo).
Parámetros comúnmente usados con FastCGI
Son los pares clave-valor a los que vamos a tener acceso dentro del script PHP que procesará el módulo de PHP FastCGI de Nginx.
ADVERTENCIA : Recuerda que si utilizas otro procesador de PHP distinto del proporcionado por el módulo de Nginx, deberás revisar la documentación de dicho procesador.
    • QUERY_STRING: Dependiendo del método empleado en la petición HTTP , podrás tener QUERY_STRING (caso GET), o argumentos (caso POST).
    • REQUEST_METHOD : Método (Verbo) HTTP emleado en la petición.
    • CONTENT_TYPE : valor mapeado acorde con la cabecera HTTP de la petición original.
    • CONTENT_LENGTH : valor mapeado acorde con la cabecera HTTP de la petición original.
    • SCRIPT_NAME
    • SCRIPT_FILENAME
    • REQUEST_URI
    • PATH_INFO : Si el valor cgi.fix_pathinfo es “1” en la configuración de PHP (php.ini), contendrá información adicional sobre el path del script.
    • PATH_TRANSLATED : Contendrá el path real en el sistema de ficheros. 
Versiones e instalación
Recuerda que las versiones que vienen de serie en tu sistema operativo , no siempre son las más recientes. Si necesitas una versión específica de PHP, tendrás dos opciones:
    • Añadir un repositorio en el cual se ofrezca un paquete de esa versión (binario precompilado). 
    • Compilar tú mismo la versión desde los ficheros fuente. 
ADVERTENCIA : Intenta no mezclar la versión que te ofrece tu sistema operativo con módulos compilados ad-hoc y viceversa.
Configuración de PHP
php.ini
En este fichero se encuentra la configuración del run-time de PHP. Dependiendo de que arquitectura y del sistema operativo que hayamos escogido , su lectura se puede producir una o varias veces. Para ver información más detallada sobre cúando se lee el fichero de configuración, te recomendamos que consultes la documentación oficial de PHP al respecto.
Por ejemplo, si hemos configurado un servidor Apache en modo mpm_prefork haciendo uso del módulo mod_php, el fichero php.ini se leerá al arrancar el servidor.
Si por el contrario, hemos escogido un servidor Apache en modo mpm_event con el módulo mod_fcgi , el fichero se leerá con cada invocación.
Pautas a tener en cuenta en Programación con PHP
Como siempre, recomendamos la lectura de las recomendaciones que da OWASP al respecto.
Este es un problema que te vas a encontrar a menudo cuando tu sólo estás encargado del despliegue pero no en la parte de la programación. Es importante el fomentar una guía de estilo en el equpo en el que estés, llegando a acuerdos entre las distintas partes implicadas. Desgraciadamente, en la mayoría de los casos esto no se produce.
Validación de Inputs y Sanitización
En un entorno profesional, esta parte generalmente “salta” cuando hay una fase de tests de seguridad. Si hay cultura de equipo, y si te acostumbras a tenerlo en cuenta desde el minuto 1, pasará a formar parte de tu trabajo, y podrás dormir más tranquilo :-)
Acceso a Mysql desde PHP
El manual oficial de PHP ofrece una serie de recomendaciones para escoger una API en proyectos en los que tengáis como base de datos MySQL. Contiene también una tabla comparativa que os ayudará a determinar qué opciones tenéis. Puedes consultar el manual en el siguiente enlace
Si nunca habéis trabajado con PDO, os recomendamos que sigáis este tutorial.

Curso de Servidores Web 
    • Montando Stacks (I) 
    • MySQL 
MySQL es un sistema de gestión de bases de datos multi-hilo, y se le suele conocer más por ser un RDBMS (Relational DabaBase Management System).
MariaDB vs MySQL
Para ver una comparativa completa, puedes consultar este enlace: MariaDB vs MySQL - Características.
Si en algún momento te planteas reemplazar MySQL por MariaDB, este documento te puede ayudar a tener en cuenta ciertos aspectos: MariaDB vs Mysql - Compatibilidad
Versiones e Instalación
RECORDATORIO : Los repositorios que vienen por defecto en un sistema operativo no suelen tener siempre la versión más reciente. Si necesitas una versión distinta a la que viene con el sistema operativo, puedes buscar en otros repositorios (añadiéndolos como en el ejemplo que hemos visto antes), o bien compilarlos ( Un proceso más complejo para gente con poca experiencia en Linux).
Configuración
/etc/my.cnf
Motores de Bases de Datos
    • MyISAM / Aria ( No transaccional) 
    • InnoDB / XtraDB (Transaccional , cumple ACID) 
Ejemplo de un stack LAMP
    • Ejemplo de un Wordpress montado sobre un stack LAMP 
Recomendamos tener a mano estos documentos para futuras consultas:
    • Apache en el que se da una visión de conjunto de toda las posibles opciones a la hora de plantear una arquitectura LAMP. 
    • MySQL, PHP and Caching 
Ejemplo de un stack LEMP
    • Ejemplo de un Wordpress montado sobre un stack LEMP 
Nginx tiene guías especializadas para muchos casos de uso: Guía de Administración de Ngnix




Curso de Servidores Web 
    • Montando Stacks (II) 
    • NodeJS 
En 2008, Ryan Dhal tuvo una idea brillante. Se planteó si era posible trasladar el entorno de Javascript al servidor. Así que se puso manos a la obra, y empleando el motor de Javascript de Chrome V8 , en 2009 presentó NodeJS, un entorno de ejecución de Javascript en el servidor.
Lo que no sabía Rhyan Dhal, era lo lejos que iba a llegar su idea. NodeJS hoy en día es una opción por la que apuesta muchas empresas, y es una de las comunidades más activas en Internet.
Los pilares de NodeJS, que le diferencian de otras soluciones de servidor son:
    • Es asíncrono, orientado a eventos (libuv)
    • Es mono-hilo en ejecución 
A efectos prácticos, la mayoría de código escrito para ejecutarse en el navegador, podrá ejecutarse en NodeJS. Pero hay que tener claras un par de cosas:
Javascript
NodeJS
window
global
DOM
No hay, pero se puede emular
no hay sistema de módulos “oficial”
CommonJS -> con Browserify puedes portar proyectos de node para que se ejecuten en el navegador
Uno de los problemas que últimamente está teniendo NodeJS, es precisamente la incompatibilidad entre ciertas versiones de NodeJS y módulos que se basaban en dicha versión ya que, al basarse en V8, cuando cambia la versión de v8 y se modifica la API de ciertas partes ( Como por ejemplo la gestión de ArrayBuffers, Streams, etc… ) y si el módulo hace uso de alguna de esas API’s y no se adapta a dicha versión, el resultado será que ese módulo no funcionará. En estos casos veremos cómo poder mantener distintas versiones de NodeJS en nuestra máquina, para aliviar un poco el problema y poder seguir utilizando módulos que no tuvieran soporte para futuras versiones.
Instalación de NodeJS
NodeJS se puede instalar de muchas maneras. Dependerá de qué sistema Operativo dispongáis y necesidades de una versión concreta. Como ya hemos comentado a lo largo del curso, tendremos desde binarios precompilados hasta la opción de compilarlo desde código fuente. Como veremos más adelante, NVM nos va a facilitar mucho la tarea de poder tener varias versiones de NodeJS en la misma máquina.
En caso de tener Windows, os recomendamos que os instaléis NodeJS , desde el binario que tenéis disponible en la página oficial de NodeJS.
NPM
Es el sistema de gestión de paquetes ( módulos ) de NodeJS. Todo proyecto de node suele incluir un fichero de texto llamado package.json en el que se indican las dependencias del proyecto. Todos los paquetes que aparecen en el package.json son procesados por NPM , y por cada uno de ellos resuelve las dependencias posibles que tuviera dicho paquete.
El sistema de módulos que utiliza es CommonJS. Hay muchos sistemas de módulos disponibles en Javascript (AMD, UMD, …) pero dada la popularidad de nodeJS, CommonJS suele ser el más utilizado. Si quieres sabe más sobre los tipos de módulos existentes en Javascript, puedes consultar este screencast o jugar con todos los ejemplos (http://curran.github.io/screencasts/jsModulesAndBuildTools/examples/viewer/#/)
Las versiones de los módulos en NPM siguen el sistema SEMVER ( Semantic Versioning ).
NVM
Es un script que nos va a permitir el poder tener varias versiones de NodeJS instaladas en la misma máquina.
Para instalarlo, sólo tenéis que ejecutar esta línea de comandos:
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash
. ~/.nvm/nvm.sh
Express
Express es uno de los proyectos más populares para montar servicios web en NodeJS. Su uso es bastante sencillo y se basa en el uso de middlewares ( plugins ) que permiten modelizar el procesamiento de una petición de manera sencilla.
La versión actual es la 4.X . Ojo con esto, porque hay mucha documentación desfasada de la anterior versión 3.X.X y el cambio de la API es importante.
En esta sesión repasaremos API, para que os hagáis una idea de las partes más importantes:
Referencia oficial de la API de Express
Módulos (Middleware) de Express útiles para distintas tareas del stack HTTP
Puedes consultar una lista de middlewares que express recomienda en el siguiente enlace
PM2 como gestor de servicio
Es un gestor de procesos de NodeJS, que se está haciendo bastante popular. Estas son algunas de sus características:
    • Modo Cluster 
    • Hot Reload 
    • Scripts de Arranque 
PM2


Curso de Servidores Web 
    • Montando Stacks (II) 
    • MongoDB 
En una base de Datos NOSQL Orientada a Documentos. Para entender un poco mejor que diferencia hay con respecto a MySQL, podéis consultar este documento en el que se os presentan una tabla concaracterísticas de uno y otro así como de operaciones básicas.
En esquema sencillo de comparación a nivel de estructura de datos entre Mysql y Mongo sería el siguiente:
Mysql
MongoDB
Tabla
Colección
Registro o Fila
Documento
Columna
campo
Join
Campos embebidos o enlazados
Veamos algunas de las ventajas
    • La estructura de los documentos almacenados en Mongo es la misma que la que tendría un objeto en Javascript, haciendo más fácil su procesamiento en Javascript.
    • El esquema puede ser flexible, es decir cada documento puede tener más o menos campos que otro documento. En Mysql las tablas tienen un número fijo de columnas.
    • Permite Agregación : Algo muy utilizado en temas de monitorización y Big Data. Básicamente consiste en ir haciendo resúmenes o acumulados de ciertas coleciones. 
Versiones e Instalación
La versión estable es la 3.X
MongoDB recomienda instalar siempre en arquitecturas de 64 bits. Hay alguna versión para 32 bits, pero desde la propia página oficial desaconsejan su uso.
Motores de MongoDB
    • WiredTiger (Por defecto para versiones 3.2+)
    • MMAPv1 (Por defecto para versiones inferiores a la 3.2)
    • In-Memory ( MongoDB Enterprise) 
Referencia oficial
Accediendo a MongoDB desde NodeJS
Uno de los módulos más populares para acceder a MongoDB desde NodeJS es Mongoose
Ejemplo de Buscador de Series de TV
En esta sesión veremos un ejemplo de instalación de una aplicación montada sobre un stack MEAN. Podéis acceder al código fuente desde aquí
